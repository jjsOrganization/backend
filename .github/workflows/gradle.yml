# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# This workflow will build a Java project with Gradle and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-gradle

name: Java CI with Gradle

on:
  push:
    branches: [ "develop" ]
  pull_request:
    branches: [ "develop" ]

jobs:
  build:
    runs-on: ubuntu-latest # 이 작업을 실행할 가상 환경의 OS를 지정합니다. 여기서는 최신 버전의 Ubuntu를 사용합니다.

    # PR이 develop 브랜치로 병합될 때만 작업을 실행하도록 조건을 설정합니다.
    # if: github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'develop'

    permissions:
      contents: read # 이 작업이 리포지토리의 콘텐츠를 읽을 수 있는 권한을 가지게 합니다.

    steps:
      - name: Checkout
        uses: actions/checkout@v4 # GitHub 리포지토리의 코드를 체크아웃하여 작업 디렉토리에 복사합니다.

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin' # JDK 17을 설치하여 Java 애플리케이션을 빌드할 수 있는 환경을 설정합니다.

#      - name: make application-dev.yml
#        run: |
#          cd ./src/main/resources
#          touch ./application-dev.yml
#          echo "${{ secrets.APPLICATION_DEV }}" > ./application-dev.yml
#        shell: bash
        # .gitignore에 의해 버전 관리에서 제외된 application-dev.yml 파일을 생성하고, GitHub Secrets에서 가져온 내용을 파일에 작성합니다.

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@417ae3ccd767c252f5661f1ace9f835f9654f2b5 # Gradle 환경을 설정합니다. 특정 버전의 Gradle을 사용하여 빌드할 수 있도록 합니다.

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew
        shell: bash # Gradle wrapper 스크립트에 실행 권한을 부여합니다. 이를 통해 빌드 명령을 실행할 수 있습니다.

      - name: Build with Gradle Wrapper
        run: ./gradlew bootJar # Gradle Wrapper를 사용하여 Java 프로젝트를 빌드합니다.

      - name: Get current time
        uses: 1466587594/get-current-time@v2
        id: current-time
        with:
          format: YYYY-MM-DDTHH-mm-ss
          utcOffset: "+09:00"
        # 현재 시간을 가져오는 액션을 실행합니다. 이를 통해 빌드 시점의 시간 정보를 확보할 수 있습니다.

      - name: Show Current Time
        run: echo "CurrentTime=$"
        shell: bash # 앞서 가져온 현재 시간을 출력합니다. 이는 로깅 및 디버깅 목적으로 유용할 수 있습니다.

      - name: make Dockerfile # .gitignore에 의해 푸시되지 않은 Dockerfile 생성
        run: |
          touch ./Dockerfile
          echo "${{ secrets.DOCKER_FILE }}" > ./Dockerfile
        shell: bash
        
      - name: Docker build
        run: |
          docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}
          docker build -t ${{ secrets.DOCKER_USERNAME }}/springjjs .
          docker push ${{ secrets.DOCKER_USERNAME }}/springjjs
        # Docker 이미지를 빌드하고, Docker Hub에 로그인한 후 이미지를 푸시합니다.

      - name: Deploy to EC2 instance
        env:
          EC2_SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          EC2_HOST: ${{ secrets.CLOUD_AWS_HOST }}
          EC2_USER: ${{ secrets.CLOUD_AWS_USERNAME }}
        run: |
          SSH_KEY_FILE=$(mktemp)
          echo "${EC2_SSH_PRIVATE_KEY}" > ${SSH_KEY_FILE}
          chmod 600 ${SSH_KEY_FILE}
          
          ssh -o StrictHostKeyChecking=no -i ${SSH_KEY_FILE} ${CLOUD_AWS_USERNAME}@${CLOUD_AWS_HOST} << EOF
          
            docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}
            docker pull ${{ secrets.DOCKER_USERNAME }}/springjjs:latest
            cd docker
            docker compose down
            docker compose up -d
            docker rm $(docker ps --filter 'status=exited' -a -q)
          
          EOF # EC2 인스턴스에 SSH로 접속하여 Docker 컨테이너를 재시작하는 명령을 실행합니다. 
          
          rm -f ${SSH_KEY_FILE} # 사용이 끝난 임시 SSH 키 파일을 삭제합니다.
